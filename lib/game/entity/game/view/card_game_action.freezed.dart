// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'card_game_action.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$CardGameAction {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() play,
    required TResult Function(int count, int? from) draw,
    required TResult Function() discard,
    required TResult Function() pass,
    required TResult Function() shuffle,
    required TResult Function() deal,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? play,
    TResult? Function(int count, int? from)? draw,
    TResult? Function()? discard,
    TResult? Function()? pass,
    TResult? Function()? shuffle,
    TResult? Function()? deal,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? play,
    TResult Function(int count, int? from)? draw,
    TResult Function()? discard,
    TResult Function()? pass,
    TResult Function()? shuffle,
    TResult Function()? deal,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Play value) play,
    required TResult Function(Draw value) draw,
    required TResult Function(Discard value) discard,
    required TResult Function(Pass value) pass,
    required TResult Function(Shuffle value) shuffle,
    required TResult Function(Deal value) deal,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Play value)? play,
    TResult? Function(Draw value)? draw,
    TResult? Function(Discard value)? discard,
    TResult? Function(Pass value)? pass,
    TResult? Function(Shuffle value)? shuffle,
    TResult? Function(Deal value)? deal,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Play value)? play,
    TResult Function(Draw value)? draw,
    TResult Function(Discard value)? discard,
    TResult Function(Pass value)? pass,
    TResult Function(Shuffle value)? shuffle,
    TResult Function(Deal value)? deal,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CardGameActionCopyWith<$Res> {
  factory $CardGameActionCopyWith(
          CardGameAction value, $Res Function(CardGameAction) then) =
      _$CardGameActionCopyWithImpl<$Res, CardGameAction>;
}

/// @nodoc
class _$CardGameActionCopyWithImpl<$Res, $Val extends CardGameAction>
    implements $CardGameActionCopyWith<$Res> {
  _$CardGameActionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$PlayImplCopyWith<$Res> {
  factory _$$PlayImplCopyWith(
          _$PlayImpl value, $Res Function(_$PlayImpl) then) =
      __$$PlayImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PlayImplCopyWithImpl<$Res>
    extends _$CardGameActionCopyWithImpl<$Res, _$PlayImpl>
    implements _$$PlayImplCopyWith<$Res> {
  __$$PlayImplCopyWithImpl(_$PlayImpl _value, $Res Function(_$PlayImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PlayImpl implements Play {
  const _$PlayImpl();

  @override
  String toString() {
    return 'CardGameAction.play()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PlayImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() play,
    required TResult Function(int count, int? from) draw,
    required TResult Function() discard,
    required TResult Function() pass,
    required TResult Function() shuffle,
    required TResult Function() deal,
  }) {
    return play();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? play,
    TResult? Function(int count, int? from)? draw,
    TResult? Function()? discard,
    TResult? Function()? pass,
    TResult? Function()? shuffle,
    TResult? Function()? deal,
  }) {
    return play?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? play,
    TResult Function(int count, int? from)? draw,
    TResult Function()? discard,
    TResult Function()? pass,
    TResult Function()? shuffle,
    TResult Function()? deal,
    required TResult orElse(),
  }) {
    if (play != null) {
      return play();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Play value) play,
    required TResult Function(Draw value) draw,
    required TResult Function(Discard value) discard,
    required TResult Function(Pass value) pass,
    required TResult Function(Shuffle value) shuffle,
    required TResult Function(Deal value) deal,
  }) {
    return play(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Play value)? play,
    TResult? Function(Draw value)? draw,
    TResult? Function(Discard value)? discard,
    TResult? Function(Pass value)? pass,
    TResult? Function(Shuffle value)? shuffle,
    TResult? Function(Deal value)? deal,
  }) {
    return play?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Play value)? play,
    TResult Function(Draw value)? draw,
    TResult Function(Discard value)? discard,
    TResult Function(Pass value)? pass,
    TResult Function(Shuffle value)? shuffle,
    TResult Function(Deal value)? deal,
    required TResult orElse(),
  }) {
    if (play != null) {
      return play(this);
    }
    return orElse();
  }
}

abstract class Play implements CardGameAction {
  const factory Play() = _$PlayImpl;
}

/// @nodoc
abstract class _$$DrawImplCopyWith<$Res> {
  factory _$$DrawImplCopyWith(
          _$DrawImpl value, $Res Function(_$DrawImpl) then) =
      __$$DrawImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int count, int? from});
}

/// @nodoc
class __$$DrawImplCopyWithImpl<$Res>
    extends _$CardGameActionCopyWithImpl<$Res, _$DrawImpl>
    implements _$$DrawImplCopyWith<$Res> {
  __$$DrawImplCopyWithImpl(_$DrawImpl _value, $Res Function(_$DrawImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? count = null,
    Object? from = freezed,
  }) {
    return _then(_$DrawImpl(
      null == count
          ? _value.count
          : count // ignore: cast_nullable_to_non_nullable
              as int,
      freezed == from
          ? _value.from
          : from // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc

class _$DrawImpl implements Draw {
  const _$DrawImpl(this.count, this.from);

  @override
  final int count;
  @override
  final int? from;

  @override
  String toString() {
    return 'CardGameAction.draw(count: $count, from: $from)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DrawImpl &&
            (identical(other.count, count) || other.count == count) &&
            (identical(other.from, from) || other.from == from));
  }

  @override
  int get hashCode => Object.hash(runtimeType, count, from);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DrawImplCopyWith<_$DrawImpl> get copyWith =>
      __$$DrawImplCopyWithImpl<_$DrawImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() play,
    required TResult Function(int count, int? from) draw,
    required TResult Function() discard,
    required TResult Function() pass,
    required TResult Function() shuffle,
    required TResult Function() deal,
  }) {
    return draw(count, from);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? play,
    TResult? Function(int count, int? from)? draw,
    TResult? Function()? discard,
    TResult? Function()? pass,
    TResult? Function()? shuffle,
    TResult? Function()? deal,
  }) {
    return draw?.call(count, from);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? play,
    TResult Function(int count, int? from)? draw,
    TResult Function()? discard,
    TResult Function()? pass,
    TResult Function()? shuffle,
    TResult Function()? deal,
    required TResult orElse(),
  }) {
    if (draw != null) {
      return draw(count, from);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Play value) play,
    required TResult Function(Draw value) draw,
    required TResult Function(Discard value) discard,
    required TResult Function(Pass value) pass,
    required TResult Function(Shuffle value) shuffle,
    required TResult Function(Deal value) deal,
  }) {
    return draw(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Play value)? play,
    TResult? Function(Draw value)? draw,
    TResult? Function(Discard value)? discard,
    TResult? Function(Pass value)? pass,
    TResult? Function(Shuffle value)? shuffle,
    TResult? Function(Deal value)? deal,
  }) {
    return draw?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Play value)? play,
    TResult Function(Draw value)? draw,
    TResult Function(Discard value)? discard,
    TResult Function(Pass value)? pass,
    TResult Function(Shuffle value)? shuffle,
    TResult Function(Deal value)? deal,
    required TResult orElse(),
  }) {
    if (draw != null) {
      return draw(this);
    }
    return orElse();
  }
}

abstract class Draw implements CardGameAction {
  const factory Draw(final int count, final int? from) = _$DrawImpl;

  int get count;
  int? get from;
  @JsonKey(ignore: true)
  _$$DrawImplCopyWith<_$DrawImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DiscardImplCopyWith<$Res> {
  factory _$$DiscardImplCopyWith(
          _$DiscardImpl value, $Res Function(_$DiscardImpl) then) =
      __$$DiscardImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DiscardImplCopyWithImpl<$Res>
    extends _$CardGameActionCopyWithImpl<$Res, _$DiscardImpl>
    implements _$$DiscardImplCopyWith<$Res> {
  __$$DiscardImplCopyWithImpl(
      _$DiscardImpl _value, $Res Function(_$DiscardImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DiscardImpl implements Discard {
  const _$DiscardImpl();

  @override
  String toString() {
    return 'CardGameAction.discard()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DiscardImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() play,
    required TResult Function(int count, int? from) draw,
    required TResult Function() discard,
    required TResult Function() pass,
    required TResult Function() shuffle,
    required TResult Function() deal,
  }) {
    return discard();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? play,
    TResult? Function(int count, int? from)? draw,
    TResult? Function()? discard,
    TResult? Function()? pass,
    TResult? Function()? shuffle,
    TResult? Function()? deal,
  }) {
    return discard?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? play,
    TResult Function(int count, int? from)? draw,
    TResult Function()? discard,
    TResult Function()? pass,
    TResult Function()? shuffle,
    TResult Function()? deal,
    required TResult orElse(),
  }) {
    if (discard != null) {
      return discard();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Play value) play,
    required TResult Function(Draw value) draw,
    required TResult Function(Discard value) discard,
    required TResult Function(Pass value) pass,
    required TResult Function(Shuffle value) shuffle,
    required TResult Function(Deal value) deal,
  }) {
    return discard(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Play value)? play,
    TResult? Function(Draw value)? draw,
    TResult? Function(Discard value)? discard,
    TResult? Function(Pass value)? pass,
    TResult? Function(Shuffle value)? shuffle,
    TResult? Function(Deal value)? deal,
  }) {
    return discard?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Play value)? play,
    TResult Function(Draw value)? draw,
    TResult Function(Discard value)? discard,
    TResult Function(Pass value)? pass,
    TResult Function(Shuffle value)? shuffle,
    TResult Function(Deal value)? deal,
    required TResult orElse(),
  }) {
    if (discard != null) {
      return discard(this);
    }
    return orElse();
  }
}

abstract class Discard implements CardGameAction {
  const factory Discard() = _$DiscardImpl;
}

/// @nodoc
abstract class _$$PassImplCopyWith<$Res> {
  factory _$$PassImplCopyWith(
          _$PassImpl value, $Res Function(_$PassImpl) then) =
      __$$PassImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PassImplCopyWithImpl<$Res>
    extends _$CardGameActionCopyWithImpl<$Res, _$PassImpl>
    implements _$$PassImplCopyWith<$Res> {
  __$$PassImplCopyWithImpl(_$PassImpl _value, $Res Function(_$PassImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PassImpl implements Pass {
  const _$PassImpl();

  @override
  String toString() {
    return 'CardGameAction.pass()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PassImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() play,
    required TResult Function(int count, int? from) draw,
    required TResult Function() discard,
    required TResult Function() pass,
    required TResult Function() shuffle,
    required TResult Function() deal,
  }) {
    return pass();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? play,
    TResult? Function(int count, int? from)? draw,
    TResult? Function()? discard,
    TResult? Function()? pass,
    TResult? Function()? shuffle,
    TResult? Function()? deal,
  }) {
    return pass?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? play,
    TResult Function(int count, int? from)? draw,
    TResult Function()? discard,
    TResult Function()? pass,
    TResult Function()? shuffle,
    TResult Function()? deal,
    required TResult orElse(),
  }) {
    if (pass != null) {
      return pass();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Play value) play,
    required TResult Function(Draw value) draw,
    required TResult Function(Discard value) discard,
    required TResult Function(Pass value) pass,
    required TResult Function(Shuffle value) shuffle,
    required TResult Function(Deal value) deal,
  }) {
    return pass(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Play value)? play,
    TResult? Function(Draw value)? draw,
    TResult? Function(Discard value)? discard,
    TResult? Function(Pass value)? pass,
    TResult? Function(Shuffle value)? shuffle,
    TResult? Function(Deal value)? deal,
  }) {
    return pass?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Play value)? play,
    TResult Function(Draw value)? draw,
    TResult Function(Discard value)? discard,
    TResult Function(Pass value)? pass,
    TResult Function(Shuffle value)? shuffle,
    TResult Function(Deal value)? deal,
    required TResult orElse(),
  }) {
    if (pass != null) {
      return pass(this);
    }
    return orElse();
  }
}

abstract class Pass implements CardGameAction {
  const factory Pass() = _$PassImpl;
}

/// @nodoc
abstract class _$$ShuffleImplCopyWith<$Res> {
  factory _$$ShuffleImplCopyWith(
          _$ShuffleImpl value, $Res Function(_$ShuffleImpl) then) =
      __$$ShuffleImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ShuffleImplCopyWithImpl<$Res>
    extends _$CardGameActionCopyWithImpl<$Res, _$ShuffleImpl>
    implements _$$ShuffleImplCopyWith<$Res> {
  __$$ShuffleImplCopyWithImpl(
      _$ShuffleImpl _value, $Res Function(_$ShuffleImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ShuffleImpl implements Shuffle {
  const _$ShuffleImpl();

  @override
  String toString() {
    return 'CardGameAction.shuffle()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ShuffleImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() play,
    required TResult Function(int count, int? from) draw,
    required TResult Function() discard,
    required TResult Function() pass,
    required TResult Function() shuffle,
    required TResult Function() deal,
  }) {
    return shuffle();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? play,
    TResult? Function(int count, int? from)? draw,
    TResult? Function()? discard,
    TResult? Function()? pass,
    TResult? Function()? shuffle,
    TResult? Function()? deal,
  }) {
    return shuffle?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? play,
    TResult Function(int count, int? from)? draw,
    TResult Function()? discard,
    TResult Function()? pass,
    TResult Function()? shuffle,
    TResult Function()? deal,
    required TResult orElse(),
  }) {
    if (shuffle != null) {
      return shuffle();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Play value) play,
    required TResult Function(Draw value) draw,
    required TResult Function(Discard value) discard,
    required TResult Function(Pass value) pass,
    required TResult Function(Shuffle value) shuffle,
    required TResult Function(Deal value) deal,
  }) {
    return shuffle(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Play value)? play,
    TResult? Function(Draw value)? draw,
    TResult? Function(Discard value)? discard,
    TResult? Function(Pass value)? pass,
    TResult? Function(Shuffle value)? shuffle,
    TResult? Function(Deal value)? deal,
  }) {
    return shuffle?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Play value)? play,
    TResult Function(Draw value)? draw,
    TResult Function(Discard value)? discard,
    TResult Function(Pass value)? pass,
    TResult Function(Shuffle value)? shuffle,
    TResult Function(Deal value)? deal,
    required TResult orElse(),
  }) {
    if (shuffle != null) {
      return shuffle(this);
    }
    return orElse();
  }
}

abstract class Shuffle implements CardGameAction {
  const factory Shuffle() = _$ShuffleImpl;
}

/// @nodoc
abstract class _$$DealImplCopyWith<$Res> {
  factory _$$DealImplCopyWith(
          _$DealImpl value, $Res Function(_$DealImpl) then) =
      __$$DealImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DealImplCopyWithImpl<$Res>
    extends _$CardGameActionCopyWithImpl<$Res, _$DealImpl>
    implements _$$DealImplCopyWith<$Res> {
  __$$DealImplCopyWithImpl(_$DealImpl _value, $Res Function(_$DealImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DealImpl implements Deal {
  const _$DealImpl();

  @override
  String toString() {
    return 'CardGameAction.deal()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DealImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() play,
    required TResult Function(int count, int? from) draw,
    required TResult Function() discard,
    required TResult Function() pass,
    required TResult Function() shuffle,
    required TResult Function() deal,
  }) {
    return deal();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? play,
    TResult? Function(int count, int? from)? draw,
    TResult? Function()? discard,
    TResult? Function()? pass,
    TResult? Function()? shuffle,
    TResult? Function()? deal,
  }) {
    return deal?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? play,
    TResult Function(int count, int? from)? draw,
    TResult Function()? discard,
    TResult Function()? pass,
    TResult Function()? shuffle,
    TResult Function()? deal,
    required TResult orElse(),
  }) {
    if (deal != null) {
      return deal();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Play value) play,
    required TResult Function(Draw value) draw,
    required TResult Function(Discard value) discard,
    required TResult Function(Pass value) pass,
    required TResult Function(Shuffle value) shuffle,
    required TResult Function(Deal value) deal,
  }) {
    return deal(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Play value)? play,
    TResult? Function(Draw value)? draw,
    TResult? Function(Discard value)? discard,
    TResult? Function(Pass value)? pass,
    TResult? Function(Shuffle value)? shuffle,
    TResult? Function(Deal value)? deal,
  }) {
    return deal?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Play value)? play,
    TResult Function(Draw value)? draw,
    TResult Function(Discard value)? discard,
    TResult Function(Pass value)? pass,
    TResult Function(Shuffle value)? shuffle,
    TResult Function(Deal value)? deal,
    required TResult orElse(),
  }) {
    if (deal != null) {
      return deal(this);
    }
    return orElse();
  }
}

abstract class Deal implements CardGameAction {
  const factory Deal() = _$DealImpl;
}
